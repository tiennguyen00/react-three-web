/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useMemo, useRef } from 'react'
import { shaderMaterial, useGLTF } from '@react-three/drei'
import { extend, GroupProps, Object3DNode, useFrame, useGraph, useThree } from '@react-three/fiber'
import * as THREE from 'three'
import vertex from '@/components/shared/gpgpu/gpgpu.vert'
import fragment from '@/components/shared/gpgpu/gpgpu.frag'
import gpgpuParticlesShader from '@/components/shared/gpgpu/particles.glsl'
import { GPUComputationRenderer } from 'three/examples/jsm/misc/GPUComputationRenderer.js'
import { useControls } from 'leva'

const GpgpuMaterial = shaderMaterial(
  {
    uSize: 0.07,
    uResolution: new THREE.Vector2(
      window.innerWidth * window.devicePixelRatio,
      window.innerHeight * window.devicePixelRatio,
    ),
    uParticlesTexture: new THREE.Texture(),
  },
  vertex,
  fragment,
)
declare module '@react-three/fiber' {
  interface ThreeElements {
    gpgpuMaterial: Object3DNode<typeof GpgpuMaterial, typeof GpgpuMaterial>
  }
}
extend({ GpgpuMaterial })

export function FleetModel(props: GroupProps) {
  const { gl } = useThree()
  const { scene } = useGLTF('/models/fleet.glb')
  const { nodes } = useGraph(scene)
  const { geometry } = nodes.boat as any
  const size = Math.ceil(Math.sqrt(geometry.attributes.position.count))
  const gpgpuMaterialRef = useRef<typeof GpgpuMaterial>(null)

  const { flowFieldInfluence, flowFieldStrength } = useControls('Points', {
    flowFieldInfluence: {
      value: 0.4,
      step: 0.1,
      min: 0.0,
      max: 1.0,
    },
    flowFieldStrength: {
      value: 0.75,
      step: 0.001,
      min: 0,
      max: 10,
    },
  })

  const { particlesVariable, particleUvArray, sizesArray, gpuCompute } = useMemo(() => {
    const gpuCompute = new GPUComputationRenderer(size, size, gl)

    /**
     * baseParticlesTexture
     */
    const baseParticleTexture = gpuCompute.createTexture()
    for (let i = 0; i < geometry.attributes.position.count; i++) {
      const i3 = i * 3
      const i4 = i * 4

      baseParticleTexture.image.data[i4 + 0] = geometry.attributes.position.array[i3 + 0] as number
      baseParticleTexture.image.data[i4 + 1] = geometry.attributes.position.array[i3 + 1] as number
      baseParticleTexture.image.data[i4 + 2] = geometry.attributes.position.array[i3 + 2] as number
      baseParticleTexture.image.data[i4 + 3] = Math.random()
    }

    /**
     * ParticlesVariable
     */
    const particlesVariable = gpuCompute.addVariable('uParticles', gpgpuParticlesShader, baseParticleTexture)
    particlesVariable.material.uniforms.uTime = new THREE.Uniform(0)
    particlesVariable.material.uniforms.uBase = new THREE.Uniform(baseParticleTexture)
    particlesVariable.material.uniforms.uDeltaTime = new THREE.Uniform(0)
    particlesVariable.material.uniforms.uFlowFieldInfluence = new THREE.Uniform(0.4)
    particlesVariable.material.uniforms.uFlowFieldStrength = new THREE.Uniform(0.75)
    gpuCompute.setVariableDependencies(particlesVariable, [particlesVariable])
    gpuCompute.init()

    /**
     * ================
     */
    const particleUvArray = new Float32Array(geometry.attributes.position.count * 2)
    const sizesArray = new Float32Array(geometry.attributes.position.count)
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const i = y * size + x
        const i2 = i * 2

        const uvX = (x + 0.5) / size
        const uvY = (y + 0.5) / size

        particleUvArray[i2 + 0] = uvX
        particleUvArray[i2 + 1] = uvY

        sizesArray[i] = Math.random()
      }
    }

    return { gpuCompute, baseParticleTexture, particlesVariable, particleUvArray, sizesArray }
  }, [])

  useFrame(({ clock }, delta) => {
    gpuCompute.compute()

    if (gpgpuMaterialRef.current) {
      const { uniforms } = gpgpuMaterialRef.current as any
      uniforms.uParticlesTexture.value = gpuCompute.getCurrentRenderTarget(particlesVariable).texture
    }

    const elapsedTime = clock.getElapsedTime()
    particlesVariable.material.uniforms.uTime.value = elapsedTime
    particlesVariable.material.uniforms.uDeltaTime.value = delta
  })

  useEffect(() => {
    particlesVariable.material.uniforms.uFlowFieldInfluence.value = flowFieldInfluence
    particlesVariable.material.uniforms.uFlowFieldStrength.value = flowFieldStrength
  }, [flowFieldInfluence, flowFieldStrength])

  return (
    <group {...props} dispose={null}>
      <points>
        <bufferGeometry drawRange={{ start: 0, count: geometry.attributes.position.count }}>
          <bufferAttribute attach='attributes-aParticlesUv' array={particleUvArray} itemSize={2} />
          <bufferAttribute attach='attributes-aColor' array={geometry.attributes.color.array} itemSize={4} />
          <bufferAttribute attach='attributes-aSize' array={sizesArray} itemSize={1} />
        </bufferGeometry>
        <gpgpuMaterial ref={gpgpuMaterialRef} />
      </points>
    </group>
  )
}

useGLTF.preload('/models/fleet.glb')
